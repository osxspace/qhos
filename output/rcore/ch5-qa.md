# CH5 QA

## link_app.S 中的 incbin 汇编

## kernel_stack 的变化和流程

## initproc 初始化流程

## fork 的核心流程

## fork 和 spawn 的区别

## waitpid 系统调用实现，进程转换实现

## exec 系统调用流程

## user_shell 执行后如何退出

## 虚拟地址空间与 copy on write 技术结合实现

## 为什么需要额外的一个idle_task_cx，不能够直接使用之前task_cx吗，为何在前一个task和后一个task之间还要夹一个idle_task_cx

这样做的主要目的是使得换入/换出进程和调度执行流在内核层各自执行在不同的内核栈上，分别是进程自身的内核栈和内核初始化时使用的启动栈。这样的话，调度相关的数据不会出现在进程内核栈上，也使得调度机制对于换出进程的Trap执行流是不可见的，它在决定换出的时候只需调用schedule而无需操心调度的事情。从而各执行流的分工更加明确了，虽然带来了更大的开销。

实际上当然可以在Trap处理中直接进行调度找到切换到哪个进程并切换过去。有兴趣的话可以试试。

idle 控制流我个人的理解：

idle_task_cx_ptr 实际上只是一个占位符。它存在的意义就是作为 __switch 的第一个参数。
run_tasks 是在 os 的入口函数中调用的，也即运行在内核系统栈。这个函数是系统的自带调度流，而非被进程所推动的调度流。
而调度操作，我们可以举例追溯 sys_yield 的实现，发现它调用 suspend_current_and_run_next，后者调用 schedule。即：进程的内核栈主动请求了将自己换出，换成新的进程。
因此，使用一个空上下文作为占位，内核的自己的调度流就不需要关心现在是谁在运行，只要换成下一个就绪任务就行，完成了解耦。