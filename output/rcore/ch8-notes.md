# CH8 线程与协程

TCOS

三个重要抽象：地址空间、进程、文件

## 理论

### 线程

- 为什么要使用线程？- 提高一个进程的并发性
- 进程和线程、信号量的历史 - Dijkstra
- 进程变成资源的容器
- 线程来处理 CPU 的调度问题
- 如何使用 - 查找示例
- 线程和进程的区别对比
  - 进程间相互独立资源，线程间相互共享进程的资源
  - 子进程与父进程地址空间和资源不同，线程则共享同一进程的地址空间和资源
  - 线程上下文切换要比进程快
- 线程设计与实现的不同方式
  - 用户态管理用户态运行 - 内核不可见的用户线程
  - 内核态管理用户态运行 - 内核课件的用户线程
  - 内核态管理内核态运行 - 内核线程
  - 混合管理运行 - 轻量级线程，混合线程
- 单核下性能是否有差别

### 协程

- 上下文切换
- 协程：函数上下文切换
- lua 作者的 paper 区分协程的维度 - 查找 pager ?
  - 对称性 - 控制传递机制
  - 有无栈
  - first class
- 协程
  - 无栈 - sp 指向协程所属的那个线程的栈指针
  - 有栈 - sp 指向自己独占的栈指针，其他通用寄存器指向当前执行点的值，pc 寄存器
- 协程切换寄存，线程切换栈，进程切换页表 - 切换的粒度越来越小
- 控制流的主动让出与恢复 - 函数级的切换
- 同步思维写异步代码
- 协程适合 IO 密集型场景处理
- 用协程来写 kernel - 一些探索
- 查找各种语言的测试用例 ？
- slides 参考信息仔细看

## 实战

- 支持线程
- 查看协程管理代码 - stackless
- Task - 对控制流执行的抽象
  - id
  - stack
  - TaskContext
  - State
- 调度
- 用户态管理 -> 内核态管理
- 有了线程后将原有的进程函数做适配
- 代码组织结构 - 数据结构和处理

## 同步互斥

- 并行编程
- 需要更好的理解
- 多线程共享资源
  - 不确定行
  - 错误不可重现
  - 出现难以重现的错误
- 共享资源导致可能带来的错误
- 原子操作 - 引入新的硬件机制
- 解决方案对比 - 引出锁的机制
  - 锁 - 锁住冰箱拿走钥匙
  - 标签机制 - 不能保证原子性
- 临界区
- 方法 - 用户态执行的程序
  - 禁用硬件中断 
    - 没有上下文切换也就没有并发 
    - 用户程序调用系统调用 - 内核提供系统调用 - 权限太大
    - 不适合多核
    - 要小心使用
  - 基于软件的解决方法 - 标记 - 能否进入临界区 - 用户态就可以解决
    - 整型标志位
    - 1981 - peterson 算法 - 孔融让梨 - flag turn 结合
    - dekkers 算法 - 课后自己研究
    - N 个线程的情况 - flag turn 机制
  - 更高级的抽象方法 - 软硬件配合 - 锁机制
    - 就是获取锁和释放锁
    - 读、改、写形成一个原子操作
      - Tets and Set
      - Cas 锁 - 加上版本号 - 自旋锁能否实现先进线出 ? - 给出一种方案？
      - Tas 锁 - 实现自旋锁 - 忙等
      - 忙等锁和等待锁
    - 缺点
      - 形成死锁
- 信号量
  - Dijkstra 提出来的
  - 都支持临界区
  - 信号量支持更全面和灵活
  - 火车信号灯的概念
  - P V 操作操作系统如何保证原子性 - 关中断
  