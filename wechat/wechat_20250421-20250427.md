## 20250421 - 周一

- [mac 环境配置](https://rcore.jiangshengdev.com/docs/env/) - rcore-guide 教材评论区
- SV39 多级页表可看成三维数组 - rcore-tutorial 教材评论区
- 看导学阶段视频 - 页面置换算法 - 导学阶段的视频学习
- 测试方式

```sh
见这个<https://learningos.cn/rCore-Camp-Guide-2025S/chapter3/5exercise.html#id5>，"指定 BASE=2 控制框架同时编译基础测例和实验测例"，要运行更全的用例见根目录的README里的Grading那段
ci-user目录下 make test CHAPTER=2
这个和那个BASE参数一样的，user下的那个makefile里是通过章节编号后面有没有个'b'判断是实验用例还是基础用例的。emmm对哦，直接改makefile就行了，把那个APPS的赋值改了就行了
```

- 问个问题，mmu是用来转va为pa的，但是我看好像有些函数调用还是会在软件层面直接调用去找页表直接去找对应的物理地址了,这里冲突吗感觉好像没有用到mmu的样子
- 内核和应用不是一张页表,所以需要用应用的页表去找到真正的物理地址

## 20250422 - 周二

- cd ci-user && make test CHAPTER=4
- ch3已经有了。buddy_system_allocator
- https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#example 这里也有一个简单的实例实现，只要内存无限，就没问题
- 推荐实现是自己实现堆内存的分配吗 - 没活可以看看glibc malloc.c
- 群友可以看看标准库std::alloc的文档 - 我从这个文档通过dbg学到了很多
- 二阶段只是预热，三阶段才开始上强度
- 这两周忙完了回来写ch8了，好像还是有点问题，如果一个空的进程既创建了信号量又创建了互斥量，那他们返回的id好像会是一样的
- 参考 CSAPP 第九章虚拟内存管理
- 默认情况下，makefile 仅编译基础测例 (BASE=1)，即无需修改框架即可正常运行的测例。 你需要在编译时指定 BASE=0 控制框架仅编译实验测例（在 os 目录执行 make run BASE=0）， 或指定 BASE=2 控制框架同时编译基础测例和实验测例

## 20250423 - 周三

- 这个sbrk是给谁用的，这个空间大小是0 - 可以去查查sbrk系统调用 - 还有brk
- memory set和task.rs里面在构造memoryset的时候传了一个参数标定是什么映射
- 请问ch8进程和线程是怎么被同时调度的呢？我看ch8的代码好像把之前进程调度的代码直接改成了线程调度，是在ch8中进程不会被抢占而只有线程会被抢占式执行吗？- 进程没有被实际调度 - 被调度的都是线程 - 我理解了！谢谢。调度task的时候是可以从TCB找到PCB从而找到页表的信息然后进行切换的
- 