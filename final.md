# 2025春季开源操作系统训练营

## 学习背景

在进行网络编程的时候，如果要提高程序的并发性能会用到 io 多路复用和协程，很多框架和语言都会有自己的实现，在逐渐深入的过程中，就会提出一些问题：

- io 多路复用 select、epoll、io_uring 是如何做到可以提高并发性的
- 阻塞和非阻塞又是如何做到的
- 到底什么是同步什么是异步
- 协程底层是如何实现的

这些问题虽然网上有很多资料，但如果自己不亲自去写一些 case 去验证，感觉是很难理解透彻的。而这些技术的实现都是直接或者间接的依赖操作系统才可以做到，也就是说要理解这些知识点，那就必须要学操作系统的知识。

正好我也在模仿着想实现一个协程框架(有栈的)，发现要用到汇编知识，发现写操作系统也需要汇编知识，于是顺手查了下比较好的操作系统课程：

- 南京大学的操作系统
- 清华大学操作系统 - ucore & rcore
- MIT xv6 操作系统

在视频网站上看到有人分享参加了开源操作系统训练营，于是便在今年 1 月份就定计划要专供下操作系统的知识，来参与下开源操作系统训练营了，也算是补上十多年前没学好的专业课吧(出来混，早晚都要还的)

另外，也想通过这次的学习，寻找一些志同道合的朋友，一起进步。

## 学习仓库

跟着老师和同学们一起学习用的代码仓库，里面包含了每次作业的提交内容

- [rustling](https://github.com/LearningOS/2025s-rustling-CreatorMetaSky)
- [rcore](https://github.com/LearningOS/2025s-rcore-CreatorMetaSky)
- [ucore](https://github.com/LearningOS/2025s-arceos-CreatorMetaSky)
- [qhos](https://github.com/osxspace/qhos) - 记录了一些学习笔记 - 记录的有些凌乱

## 各阶段学习内容总结

### 第一阶段 rustling

rustling 很久之前曾经刷过一遍了，这次是温故知新，复习了以下知识点：

- rust 的基本语法
- 模式匹配
- 所有权转移
- 容器智能指针
- 包管理机制
- 使用 async await

### 第二阶段 rcore

在学习 rCore 的过程中，首先通读了一遍 [rCore-Tutorial-Guide](https://learningos.cn/rCore-Tutorial-Guide-2025S)， 发现其中大部分章节只是罗列了代码的改动，对于基础知识原理，并没有过多的介绍。
又开始阅读学习 [rCore-Book](https://rcore-os.cn/rCore-Tutorial-Book-v3)，后续配合陈渝老师导学阶段的视频(2022年教学视频)，才逐渐走上了学习的正轨。学到了以下知识：

**构建操作系统的步骤**

- env setup - 模拟器搭建裸机运行环境
- libos - 在内核上跑一个最简单的程序
- batchos - 支持批量运行多个程序 - 引入特权级机制
- taskos - 实现分时多任务执行
- asos - 地址空间以及映射
- pos - 进程 - 从 TCB 到 PCB 的进化
- fos - 支持文件系统 - 从文件读取程序执行
- ipcos - 进程间通信 - shell 的方式进程进程切换
- tcos - 线程、协程 - 进程对应资源，线程对应调度

**操作系统内核核心组件**

- 地址空间
- 进程管理和切换
- 文件系统

**学到的具体知识点**

- 程序的内存布局结构、如何通过 linker.ld 去修改程序布局
- 页表机制以及虚拟地址到物理地址的映射方式
- 进程的协作式调度和抢占式调度以及不同的调度算法的历史演进
- 文件系统 inode 的结构组织方式，为深入理解一切皆 io 打下基础
- 从进程发展的历史的角度去理解 fork exec spawn
- 进程间通信 pipe 和 shell
- 从操作系统源码层面深入的理解进程、线程、绿色线程以及它们的异同
- 理解互斥、同步的概念，锁、信号量、条件变量

**帮助理解的知识点**

- 操作系统的启动流程
- 中断和崩溃信号量机制的实现
- 内存分配和管理机制
- IO 多路复用技术
- 协程以及调度实现
- 各种锁的实现原理
- RingBuffer
- LRU

通过上述知识的学习，终于明白了操作系统是为上层应用开发提供硬件抽象的一种系统软件实现这句话，也为我揭开了操作系统的神秘面纱

### 第三阶段 arceos

arceos 这部分主要是把老师的上课视频给走了一遍，个人理解就是把 rCore 中的各部分代码用 rust 的包管理机制打散，最终做到通过拼装组件就可以形成操作系统的效果，类似应用开发中的模块化和组件化。

**学到的知识点**

- unikernel 调用流程，如何从应用层通过系统调用调用内核的实现
- 如何拼装新的模块到 unikernel 中
- 理解 unikernel 到 宏内核的转变过程 - 解决特权级切换(用户态到内核态的切换)、地址空间的问题是关键
- 能够运行标准 linux 二进制 - 这块还是挺感兴趣的
- hypervisor 这块牵扯到在虚拟环境中运行 rCore 操作系统 - 个人理解相当于在操作系统中再次嵌套操作系统 - 学的有点吃力了

## 总结到的学习方法

### 渐进式的学习

- what - 某个技术是什么，有个初步的认识
- when - 什么时候用，在什么情况下或者说上下文下使用这种技术
- how - 如何用这种技术，如何写代码
- why - 为什么要用，为什么要使用这种技术
- build - 内部是如何实现的，自己写一个

### 如何高效学习

就像面试自己一样，不断地向自己提问题是最好的学习方式，这样才能加深理解，才算是真正理解

## 遗憾之处

在参加这次训练营的过程中，只是走马观花的看和了解了一些基础知识和概念，虽然也做了课后作业，但是跟自己实际上手去实现还是差着十万八千里，对于一些用到的库，基本都是拿来主义，也没有深入的去探索其内部的实现原理，如：内存分配算法，进程调度算法、rust-sbi，希望自己以后还是能脚踏实地的从头跟着 rCore-Book 手搓一个真正自己的操作系统。